# 898. Bitwise ORs of Subarrays

**Difficulty:** Medium  
**Problem Link:** [LeetCode 898](https://leetcode.com/problems/bitwise-ors-of-subarrays/)

---

## Problem Description

Given an integer array `arr`, return the number of **distinct** values generated by taking the **bitwise OR** of all possible subarrays.

A subarray is a contiguous portion of the array.

---

### Example

**Input:**
```python
arr = [1, 2, 4]
```

**Output:**
```python
6
```

### Explanation:

The bitwise ORs of subarrays are:

- `[1] → 1`

- `[2] → 2`

- `[4] → 4`

- `[1, 2] → 1 | 2 = 3`

- `[2, 4] → 2 | 4 = 6`

- `[1, 2, 4] → 1 | 2 | 4 = 7`

So, the distinct results are `{1, 2, 3, 4, 6, 7}` → total = 6.

###  Approach

We maintain a rolling set of **current OR values** for subarrays ending at each index.

- For each element `num`:

- - Start a new set `curr` containing just `num`.

- - For each OR result `val` from the previous step, calculate `num | val` and add it to curr.

- - Add all values in `curr` to the global `result` set.

- - Assign `curr` to `prev` for the next iteration.

This way, we avoid redundant recomputation while capturing all possible OR combinations.

### Complexity

- **Time Complexity:** `O(n * 32)`
Each element can add up to 32 different OR combinations due to 32-bit integers.

- **Space Complexity:** `O(n * 32)`
Space for tracking unique OR values.

### Tags

`Array`, `Bit-Manipulation`, `Dynamic-Programming`, `Set`

### Notes

- Using sets ensures we only keep distinct OR values.

- Clever reuse of previous results avoids brute-force O(n²) time.